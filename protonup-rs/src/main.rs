use clap::Parser;

use inquire::{Select, Text};

use std::fmt;

use libprotonup::{apps, files, github, variants};

mod download;
mod file_path;
mod helper_menus;
mod manage_apps;

use download::{download_file, unpack_file};
use helper_menus::{confirm_menu, tag_menu, variants_menu};
use manage_apps::manage_apps_routine;

#[derive(Debug, Parser)]
struct Opt {
    /// Skip Menu, auto detect apps and download using default parameters
    #[arg(short, long)]
    quick_download: bool,
}

#[derive(Debug, Copy, Clone)]
#[allow(clippy::upper_case_acronyms)]
enum InitialMenu {
    QuickUpdate,
    DoanloadForSteam,
    DoanloadForLutris,
    DownloadIntoCustomLocation,
    ManageExistingInstallations,
}

impl InitialMenu {
    // could be generated by macro
    const VARIANTS: &'static [InitialMenu] = &[
        Self::QuickUpdate,
        Self::DoanloadForSteam,
        Self::DoanloadForLutris,
        Self::DownloadIntoCustomLocation,
        Self::ManageExistingInstallations,
    ];
}

impl fmt::Display for InitialMenu {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            Self::QuickUpdate => write!(f, "Quick Update (detect apps and auto download)"),
            Self::DoanloadForSteam => write!(f, "Download GE-Proton for Steam"),
            Self::DoanloadForLutris => write!(f, "Download GE-Proton/Wine-GE for Lutris"),
            Self::DownloadIntoCustomLocation => {
                write!(f, "Download GE-Proton/Wine-GE into custom location")
            }
            Self::ManageExistingInstallations => write!(f, "Manage Existing Proton Installations"),
        }
    }
}

#[tokio::main]
async fn main() {
    // run quick downloads and skip InitialMenu
    if run_quick_downloads().await {
        return;
    }

    // Default Parameters
    let source: variants::VariantParameters;
    let mut install_dirs: Vec<String> = vec![];
    let mut tags: Vec<String> = vec![];

    let mut should_open_tag_selector = false;
    let mut should_open_dir_selector = false;
    let mut manage_existing_versions = false;
    let mut should_detect_apps = false;
    let mut apps_to_use: Vec<apps::AppInstallations> = vec![];
    let mut selected_app: Option<apps::App> = None;

    let answer: InitialMenu = Select::new(
        "ProtonUp Menu: Chose your action:",
        InitialMenu::VARIANTS.to_vec(),
    )
    .with_page_size(10)
    .prompt()
    .unwrap_or_else(|_| std::process::exit(0));

    // Set parameters based on users choice
    match answer {
        InitialMenu::QuickUpdate => {
            should_detect_apps = true;
        }
        InitialMenu::DoanloadForSteam => {
            selected_app = Some(apps::App::Steam);
            should_open_tag_selector = true;
        }
        InitialMenu::DoanloadForLutris => {
            selected_app = Some(apps::App::Lutris);
            should_open_tag_selector = true;
        }
        InitialMenu::DownloadIntoCustomLocation => {
            should_open_dir_selector = true;
            should_open_tag_selector = true;
        }
        InitialMenu::ManageExistingInstallations => manage_existing_versions = true,
    }

    // This is where the execution happens

    // If the user wants to manage existing installations, we skip the rest of the menu
    if manage_existing_versions {
        manage_apps_routine();
        return;
    }

    if should_detect_apps {
        apps_to_use = apps::list_installed_apps();
        if apps_to_use.is_empty() {
            println!("Could not find any version of Steam or Lutris. Please install at least one app before using this feature.");
            return;
        }
        println!(
            "Found the following apps: {}",
            apps_to_use
                .iter()
                .map(|app| app.to_string())
                .collect::<Vec<String>>()
                .join(", ")
        );

        // TODO: this should be done in a single place. But here we use the default for every app, and in the other part we install all selected tags for all selected apps
        for app_inst in &apps_to_use {
            let variant = app_inst.into_app().app_default_variant();
            let destination = app_inst.default_install_dir().to_string();
            println!(
                "\nQuick Download: {} for {} into -> {}\n",
                variant,
                app_inst.into_app(),
                destination
            );
            let file = download_file("latest", &variant.parameters())
                .await
                .unwrap();
            unpack_file(&file, &destination, &variant.parameters())
                .await
                .unwrap_or_else(|_| std::process::exit(0));
        }
        return;
    }

    // the rest of th execution is for updating/installing new versions
    if should_open_dir_selector {
        let current_dir = std::env::current_dir().unwrap_or_else(|_| std::process::exit(0));
        let help_message = format!("Current directory: {}", &current_dir.to_string_lossy());
        let answer = Text::new("Installation path:")
            .with_autocomplete(file_path::FilePathCompleter::default())
            .with_help_message(&help_message)
            .with_default(&current_dir.to_string_lossy())
            .prompt();

        match answer {
            Ok(path) => {
                println!("Will use the custom path: {}", path);
                install_dirs.push(path)
            }
            Err(error) => {
                println!("Error choosing custom path. Using the default. Error: {error:?}");
            }
        };
    }

    let source_options = match selected_app {
        Some(app) => app.app_available_variants(),
        None => variants::ALL_VARIANTS.to_vec(),
    };

    if source_options.len() == 1 {
        source = source_options[0].parameters();
    } else {
        source = Select::new("Chose the variant you want to install:", source_options)
            .prompt()
            .map(|variant| variant.parameters())
            .unwrap_or_else(|_| std::process::exit(0));
    };

    // if empty, no apps were detected, so we ask the user to chose one
    if apps_to_use.is_empty() && selected_app.is_some() {
        apps_to_use = apps::list_installed_apps();
        if !apps_to_use.is_empty() {
            // filter detected app installations that match selected app
            apps_to_use.retain(|app_inst| app_inst.into_app() == selected_app.unwrap());
            apps_to_use.retain(|app_inst| {
                confirm_menu(
                    format!("Detected {app_inst} installation. Use it?"),
                    String::from("If you have multiple install options, you can chose all of them"),
                    true,
                )
            })
        }

        // if apps_to_use is empty, list default options
        if apps_to_use.is_empty() {
            apps_to_use = variants_menu(
                "Chose the app you want to install for:",
                selected_app.unwrap().app_installations(),
            )
            .unwrap_or_else(|_| std::process::exit(0));
        }
    }

    // if still no apps were selected
    if apps_to_use.is_empty() && selected_app.is_some() {
        return;
    }

    // past this point, either a path was manually selected or selected_app is not empty
    if install_dirs.is_empty() {
        install_dirs = apps_to_use
            .iter()
            .map(|app_inst| app_inst.default_install_dir().to_string())
            .collect();
    }

    if should_open_tag_selector {
        tags = vec![];
        let release_list = match github::list_releases(&source).await {
            Ok(data) => data,
            Err(e) => {
                eprintln!("Failed to fetch Github data, make sure you're connected to the internet.\nError: {}", e);
                std::process::exit(1)
            }
        };
        let tag_list: Vec<String> = release_list.into_iter().map(|r| (r.tag_name)).collect();
        let list = match tag_menu("Select the versions you want to download :", tag_list) {
            Ok(tags) => tags,
            Err(e) => {
                eprintln!("The tag list could not be processed.\nError: {}", e);
                vec![]
            }
        };
        for tag_iter in list.iter() {
            let tag = String::from(tag_iter);
            tags.push(tag);
        }
    } else {
        let tag = match github::fetch_data_from_tag("latest", &source).await {
            Ok(data) => data,
            Err(e) => {
                eprintln!("Failed to fetch Github data, make sure you're connected to the internet.\nError: {}", e);
                std::process::exit(1)
            }
        };
        tags.push(tag.version)
    }

    tags.retain(|tag_name| {
        // Check if versions exist in disk.
        // If they do, ask the user if it should be overwritten
        !(install_dirs
            .iter()
            .any(|install_dir| files::check_if_exists(install_dir, tag_name))
            && !confirm_menu(
                format!("Version {tag_name} exists in the installation path. Overwrite?"),
                String::from("If you choose yes, you will re-install it."),
                false,
            ))
    });

    // install the versions that are in the tags array, into the locations that are in the install_dirs array
    for tag_name in tags.clone() {
        let tag = match github::fetch_data_from_tag(&tag_name, &source).await {
            Ok(data) => data,
            Err(e) => {
                eprintln!("Failed to fetch Github data, make sure you're connected to the internet.\nError: {}", e);
                std::process::exit(1)
            }
        };

        match download_file(&tag_name, &source).await {
            Ok(file) => {
                // TODO: should just upack once and copy to all folders
                for install_path in &install_dirs {
                    unpack_file(&file, install_path, &source).await.unwrap();
                }
            }
            Err(e) => {
                eprintln!(
                    "Error downloading {}, make sure you're connected to the internet\nError: {}",
                    tag.version, e
                )
            }
        }
    }
}

async fn run_quick_downloads() -> bool {
    let Opt { quick_download } = Opt::parse();

    if quick_download {
        let found_apps = apps::list_installed_apps();
        if found_apps.is_empty() {
            println!("No apps found. Please install at least one app before using this feature.");
            return false;
        }
        println!(
            "Found the following apps: {}",
            found_apps
                .iter()
                .map(|app| app.to_string())
                .collect::<Vec<String>>()
                .join(", ")
        );

        for app_inst in &found_apps {
            let variant = app_inst.into_app().app_default_variant();
            let destination = app_inst.default_install_dir().to_string();
            println!(
                "\nQuick Download: {} for {} into -> {}",
                variant,
                app_inst.into_app(),
                destination
            );
            let file = download_file("latest", &variant.parameters())
                .await
                .unwrap();
            unpack_file(&file, &destination, &variant.parameters())
                .await
                .unwrap_or_else(|e| {
                    eprintln!(
                        "Failed unpacking file {} into {}. Error: {}",
                        file.to_string_lossy(),
                        destination,
                        e
                    );
                });
        }
    }

    quick_download
}
