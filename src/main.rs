use inquire::{CustomUserError, MultiSelect, Select, Text};
use std::fmt;
use std::fs;
use std::fs::create_dir_all;
use structopt::StructOpt;

use protonup_rs::*;

#[derive(Debug, StructOpt)]
struct Opt {
    // /// install a specific version
    // #[structopt(short, long)]
    // tag: Option<String>,
    // #[structopt(short, long)]
    // /// list installed versions
    // list: Option<String>,
    // /// remove existing installations
    // #[structopt(short, long)]
    // remove: Option<String>,
    // /// set specific output
    // #[structopt(short, long)]
    // output: Option<String>,
    // /// set installation directory
    // #[structopt(short, long)]
    // dir: Option<String>,
    // /// disable prompts and logs
    /// Skip Menu and download latest direclty
    #[structopt(short, long)]
    quick_download: bool,
    // /// download only
    // #[structopt(long)]
    // download: bool,
    // /// list available versions
    // #[structopt(long)]
    // releases: bool,
}

#[derive(Debug, Copy, Clone)]
#[allow(clippy::upper_case_acronyms)]
enum Menu {
    QuickUpdate,
    ChoseReleases,
    ChoseReleasesCustomDir,
}

impl Menu {
    // could be generated by macro
    const VARIANTS: &'static [Menu] = &[
        Self::QuickUpdate,
        Self::ChoseReleases,
        Self::ChoseReleasesCustomDir,
    ];
}

impl fmt::Display for Menu {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            Self::QuickUpdate => write!(f, "Quick Update (Download latest GE Proton)"),
            Self::ChoseReleases => write!(f, "Chose GE Proton Releases from list"),
            Self::ChoseReleasesCustomDir => write!(
                f,
                "Chose GE Proton Releases and install to custom directory"
            ),
        }
    }
}

fn tag_menu(options: Vec<String>) -> Vec<String> {
    let ans = MultiSelect::new("Select the Versions you want to download:", options).prompt();

    match ans {
        Ok(list) => return list,

        Err(_) => {
            println!("The tag list could not be processed");
            return vec![];
        }
    }
}

#[tokio::main]
async fn main() {
    let Opt {
        // tag,
        // list,
        // remove,
        // output,
        // dir,
        quick_download,
        // download,
        // releases,
    } = Opt::from_args();

    if quick_download {
        download_file("latest", constants::DEFAULT_INSTALL_DIR.to_string()).await;
        return;
    }

    let ans: Menu = Select::new("ProtonUp Menu: Chose your action:", Menu::VARIANTS.to_vec())
        .prompt()
        .unwrap();

    match ans {
        Menu::QuickUpdate => {
            download_file("latest", constants::DEFAULT_INSTALL_DIR.to_string()).await;
            return;
        }
        Menu::ChoseReleases => {
            let release_list = protonup_rs::github::list_releases().await.unwrap();
            let tag_list: Vec<String> = release_list
                .into_iter()
                .map(|r| (r.tag_name.clone()))
                .collect();
            let list = tag_menu(tag_list);
            for tag in list.iter() {
                download_file(tag, constants::DEFAULT_INSTALL_DIR.to_string()).await;
            }
            return;
        }
        Menu::ChoseReleasesCustomDir => {
            let ans = Text::new("Instalation Path: ")
                .with_suggester(&suggest_file_paths)
                .with_completer(&complete_file_path)
                .prompt();

            let chosen_path = match ans {
                Ok(path) => path,
                Err(error) => {
                    println!(
                        "Error chosing custom path. Using the default. Error: {:?}",
                        error
                    );
                    constants::DEFAULT_INSTALL_DIR.to_string()
                }
            };
            let release_list = protonup_rs::github::list_releases().await.unwrap();
            let tag_list: Vec<String> = release_list
                .into_iter()
                .map(|r| (r.tag_name.clone()))
                .collect();
            let list = tag_menu(tag_list);
            for tag in list.iter() {
                download_file(tag, chosen_path.clone()).await;
            }
            return;
        }
    }
}

pub async fn download_file(tag: &str, install_path: String) -> Result<(), String> {
    let install_dir = utils::expand_tilde(install_path).unwrap();
    let mut temp_dir = utils::expand_tilde(constants::TEMP_DIR).unwrap();

    let download = github::fetch_data_from_tag(tag).await.unwrap();

    temp_dir.push(format!("{}.tar.gz", &download.version));

    // install_dir
    create_dir_all(&install_dir).unwrap();

    let git_hash = file::download_file_into_memory(&download.sha512sum)
        .await
        .unwrap();

    if temp_dir.exists() {
        fs::remove_file(&temp_dir);
    }

    file::download_file_progress(&download.download, download.size, &temp_dir)
        .await
        .unwrap();

    if !file::hash_check_file(temp_dir.to_str().unwrap().to_string(), git_hash) {
        return Err("Failed checking file hash".to_string());
    }
    println!("Unpacking files into install location. Please wait");
    file::decompress(temp_dir, install_dir).unwrap();
    return Ok(());
}

fn suggest_file_paths(input: &str) -> Result<Vec<String>, CustomUserError> {
    Ok(list_paths(input)?)
}

fn complete_file_path(input: &str) -> Result<Option<String>, CustomUserError> {
    // Implementation from https://rosettacode.org/wiki/Longest_common_prefix#Rust
    fn longest_common_prefix<T: AsRef<[u8]>>(list: &[T]) -> Option<Vec<u8>> {
        if list.is_empty() {
            return None;
        }
        let mut ret = Vec::new();
        let mut i = 0;
        loop {
            let mut c = None;
            for word in list {
                let word = word.as_ref();
                if i == word.len() {
                    return Some(ret);
                }
                match c {
                    None => {
                        c = Some(word[i]);
                    }
                    Some(letter) if letter != word[i] => return Some(ret),
                    _ => continue,
                }
            }
            if let Some(letter) = c {
                ret.push(letter);
            }
            i += 1;
        }
    }

    Ok(longest_common_prefix(&list_paths(input)?)
        .map(|bytes| String::from_utf8_lossy(&bytes).to_string()))
}

fn list_paths(root: &str) -> std::io::Result<Vec<String>> {
    let mut suggestions = vec![];

    let mut input_path = std::path::PathBuf::from(root);
    if let Some(parent) = input_path.parent() {
        if !input_path.exists() || !input_path.is_dir() || !root.ends_with('/') {
            input_path = parent.to_path_buf();
        }
    }
    if root.is_empty() {
        input_path = std::env::current_dir()?;
    }
    if !input_path.exists() {
        return Ok(vec![]);
    }

    for entry in std::fs::read_dir(input_path)? {
        let path = entry?.path();
        let path_str = path.to_string_lossy();

        if path_str.starts_with(root) {
            let path = if path.is_dir() {
                format!("{}/", path_str)
            } else {
                path_str.to_string()
            };
            suggestions.push(path);
        }
    }

    Ok(suggestions)
}
